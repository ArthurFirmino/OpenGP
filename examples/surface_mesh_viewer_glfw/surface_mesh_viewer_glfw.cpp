/// Simple mesh viewer based on GLFW
/// Copyright (C) 2014 - Andrea Tagliasacchi
/// Copyright (C) 2014 - Minh Dang
/// @see https://code.google.com/p/opengl-tutorial-org/source/browse/tutorial08_basic_shading/tutorial08.cpp
/// @see http://www.glfw.org

#include <OpenGP/Surface_mesh.h>
#include <OpenGP/surface_mesh/bounding_box.h>
#include <OpenGP/GL/glfw_helpers.h>
#include <OpenGP/GL/EigenOpenGLSupport3.h> 
#include <OpenGP/GL/Trackball.h>

using namespace opengp;
using namespace std;

/// Automatically generated by the cmake macro "target_stringify_shader"
/// from the files vshader.glsl and fshader.glsl
#include "vshader.h"
#include "fshader.h"

/// Viewer global status
Surface_mesh mesh;
std::vector<unsigned int> triangles; 

/// @todo Find a better place where to put it
GLuint programID;

/// Matrix stack
Eigen::Matrix4f projection;
Eigen::Matrix4f model;
Eigen::Matrix4f view;

template <class Derived>
void set_uniform_variable(GLuint programID, const char* NAME, Derived& value){
    GLuint mvp_id = glGetUniformLocation(programID, NAME);
    Eigen::glUniform(mvp_id, value);  
}

/// OpenGL initialization
void init(){
    ///----------------------- DATA ----------------------------
    auto vpoints = mesh.get_vertex_property<Point>("v:point");
    auto vnormals = mesh.get_vertex_property<Normal>("v:normal");
    assert(vpoints);
    assert(vnormals);    
    
    ///---------------------- TRIANGLES ------------------------
    triangles.clear();
    for(auto f: mesh.faces())
        for(auto v: mesh.vertices(f))
            triangles.push_back(v.idx());
    
    ///---------------------- OPENGL GLOBALS--------------------
    glClearColor(1.0f, 1.0f, 1.0f, 0.0f); ///< background
    glEnable(GL_DEPTH_TEST); // Enable depth test
    // glDisable(GL_CULL_FACE); // Cull triangles which normal is not towards the camera
        
    /// Compile the shaders
    programID = compile_shaders(vshader, fshader);
    if(!programID) exit(EXIT_FAILURE);
    glUseProgram( programID );
    
    ///---------------------- CAMERA ----------------------------
    {
        typedef Eigen::Vector3f vec3;
        typedef Eigen::Matrix4f mat4;
        
        /// Define projection matrix (FOV, aspect, near, far)
        projection = Eigen::perspective(45.0f, 4.0f/3.0f, 0.1f, 10.f);
        // cout << projection << endl;

        /// Define the view matrix (camera extrinsics)
        vec3 cam_pos(0,0,5);
        vec3 cam_look(0,0,-1); /// Remember: GL swaps viewdir
        vec3 cam_up(0,1,0);
        view = Eigen::lookAt(cam_pos, cam_look, cam_up);
        // cout << view << endl;
        
        /// Define the modelview matrix
        model = mat4::Identity();
        // cout << model << endl;  
        
        /// Set initial matrices
        set_uniform_variable(programID,"M",model); ///< to get world coordinates
        set_uniform_variable(programID,"MV",view*model); ///< to get camera coordinates
        set_uniform_variable(programID,"MVP",projection*view*model); ///< to get clip coordinates         
    }
    
    ///---------------------- LIGHT -----------------------------
    {
        Vec3f light_dir(0,0,1);
        set_uniform_variable(programID,"LDIR",light_dir); ///< to get camera coordinates
    }
    
    ///---------------------- VARRAY ----------------------------    
    {
        GLuint VertexArrayID;
        glGenVertexArrays(1, &VertexArrayID);
        glBindVertexArray(VertexArrayID);  
    }
        
    ///---------------------- BUFFERS ----------------------------    
    GLuint vertexbuffer, normalbuffer, trianglebuffer; 
    {
        /// Load mesh vertices
        glGenBuffers(1, &vertexbuffer); 
        glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer);
        glBufferData(GL_ARRAY_BUFFER, mesh.n_vertices() * sizeof(Vec3f), vpoints.data(), GL_STATIC_DRAW); 
        
        /// Load mesh normals    
        glGenBuffers(1, &normalbuffer);
        glBindBuffer(GL_ARRAY_BUFFER, normalbuffer);
        glBufferData(GL_ARRAY_BUFFER, mesh.n_vertices() * sizeof(Vec3f), vnormals.data(), GL_STATIC_DRAW);     
        
        /// Triangle indexes buffer
        glGenBuffers(1, &trianglebuffer);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, trianglebuffer);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, triangles.size() * sizeof(unsigned int), &triangles[0], GL_STATIC_DRAW);
    }

    ///---------------------- SHADER ATTRIBUTES ----------------------------    
    {
        /// Readability constants
        enum ATTRIBUTES{VPOS=0, VNOR=1};      
        
        /// Vertex positions in VPOS
        glEnableVertexAttribArray(VPOS);
        glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer);
        glVertexAttribPointer(VPOS, 3, GL_FLOAT, NOT_NORMALIZED, ZERO_STRIDE, ZERO_BUFFER_OFFSET);
        
        /// Vertex normals in VNOR
        glEnableVertexAttribArray(VNOR);
        glBindBuffer(GL_ARRAY_BUFFER, normalbuffer);
        glVertexAttribPointer(VNOR, 3, GL_FLOAT, GL_TRUE, ZERO_STRIDE, ZERO_BUFFER_OFFSET);
    }
}

/// OpenGL render loop
void display(){
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glDrawElements(GL_TRIANGLES, triangles.size(), GL_UNSIGNED_INT, ZERO_BUFFER_OFFSET);
}


namespace TrackballController{
    Eigen::Matrix4f scale_;
    Eigen::Matrix4f rotation_;
    Eigen::Matrix4f old_rotation_;
    Eigen::Matrix4f translation_;
    Trackball trackball_;
    int width_;
    int height_;

    void update_matrices(){
        model = translation_ * rotation_;
        set_uniform_variable(programID,"M",model);
        set_uniform_variable(programID,"MV",view*model);
        set_uniform_variable(programID,"MVP",projection*view*model);
    }
    
    void resize(int width, int height){
        width_ = width;
        height_ = height;
        glViewport(0, 0, width, height);
    }    
    
    void keyboard(int key, int action){
        if (action == GLFW_PRESS) {
            switch (key) {
            case GLFW_KEY_ESC:
                glfwCloseWindow();
                break;
            case GLFW_KEY_SPACE:
                break;
            }
        }
    }
    
    void mouse_button(int button, int action) {
        if (button == GLFW_MOUSE_BUTTON_LEFT && action == GLFW_PRESS) {
          old_rotation_ = rotation_;

          int x_i, y_i;
          glfwGetMousePos(&x_i, &y_i);
          const float x = 2.0f * static_cast<float>(x_i) / width_ - 1.0f;
          const float y = 1.0f - 2.0f * static_cast<float>(y_i) / height_;

          trackball_.BeginDrag(x, y);
        }
    }

    void mouse_move(int x, int y, int old_x, int old_y){
        bool view_matrices_changed = false;

        // Maya style controls.
        if (glfwGetMouseButton(GLFW_MOUSE_BUTTON_LEFT) == GLFW_PRESS) {
          const float x_f = 2.0f * static_cast<float>(x) / width_ - 1.0f;
          const float y_f = 1.0f - 2.0f * static_cast<float>(y) / height_;

          trackball_.Drag(x_f, y_f);
          rotation_ = trackball_.incremental_rotation() * old_rotation_;

          view_matrices_changed = true;
        }

        const float dx = x - old_x;
        const float dy = y - old_y;

        // Pan
        if (glfwGetMouseButton(GLFW_MOUSE_BUTTON_MIDDLE) == GLFW_PRESS) {
          const float scale = 0.05f;

          translation_ *= Eigen::Affine3f(Eigen::Translation3f(scale * dx, -scale * dy, 0.0f)).matrix();

          view_matrices_changed = true;
        }

        // Zoom
        if (glfwGetMouseButton(GLFW_MOUSE_BUTTON_RIGHT) == GLFW_PRESS) {
          const float scale = 0.05f;
          translation_ *= Eigen::Affine3f(Eigen::Translation3f(0.0f, 0.0f, scale * dy)).matrix();
          view_matrices_changed = true;
        }

        if (view_matrices_changed) {
          update_matrices();
        }
    }

    void mouse_pos(int x, int y) {
        static int old_x = x;
        static int old_y = y;
        mouse_move(x, y, old_x, old_y);
        old_x = x;
        old_y = y;
    }
    
    /// @todo implement mouse movement
    static void mouse_wheel(int /*pos*/) {
        
    }
    
    void hook(){
        translation_ = Eigen::Matrix4f::Identity();
        rotation_ = Eigen::Matrix4f::Identity();
        old_rotation_ = Eigen::Matrix4f::Identity();
        scale_ = Eigen::Matrix4f::Identity();
        
        glfwSetKeyCallback(keyboard);
        glfwSetMouseButtonCallback(mouse_button);
        glfwSetMousePosCallback(mouse_pos);
        glfwSetMouseWheelCallback(mouse_wheel);
        glfwSetWindowSizeCallback(resize);        
    }
}

/// Entry point
int main(int argc, char** argv){
    if(argc!=2){
        cout << "usage: \nsurface_mesh_viewer_glfw bunny.obj" << endl;
        return EXIT_FAILURE;
    }
    
    mesh.read(argv[1]);
    // mesh.property_stats();
    mesh.triangulate();
    mesh.update_vertex_normals();
    cout << "input: '" << argv[1] << "' num vertices " << mesh.vertices_size() << endl;
    cout << "BBOX: " << bounding_box(mesh) << endl;
        
    glfwInitWindowSize(640, 480);
    glfwCreateWindow("mesh viewer");
    glfwDisplayFunc(display);
    init();
    TrackballController::hook();
    glfwMainLoop();

    return EXIT_SUCCESS;
}
